#include <iostream>
#include <cstdlib>
#include <ctime>

void arr_add(int*& arr, int length, int num) {
	if (num <= 0)
		return;
	int* tmp = new int[length + num]{};
	for (int i = 0; i < length; i++)
		tmp[i] = arr[i];
	delete[] arr;
	arr = tmp;
}

int main(){
	setlocale(LC_ALL, "Russian");
	int n;

	//  ***** Динамическая память. *****
	int* pointer = new int; // Направление указателя на произвольный участок динамеческой памяти
	// размером в 4 байта (т.к int).
	
	*pointer = 15; // Запись в динамическую память числа 15.
	std::cout << "pointer = " << pointer << std::endl;
	std::cout << "*pointer = " << *pointer << std::endl;

	delete pointer; // Освобождение (очистка) области динамической памяти
	// на которую направлен указатель. Необходимо во избежание утечки памяти .

	pointer = new int; // Выделение нового участка динамической памяти.
	std::cout << "pointer = " << pointer << std::endl;
	*pointer = 7;
	std::cout << "*pointer = " << *pointer << std::endl;
	
	delete pointer;

	// Утечка памяти.
	/* Утечка памяти - явление, в ходе которого программа не может освободить выделенные
	ранее участки динамической памяти. Возникает из-за неправильного использования указателей.*/

	//  ***** Динамические массивы. *****
	std::cout << "Введите размер массива -> ";
	int size;
	std::cin >> size;
	int* d_arr = new int[size]; // Выделение динамической памяти для хранения массива.

	std::cout << "Ввод массива:\n";
	for (int i = 0; i < size; i++) {
		std::cout << "Введите " << i + 1 << "-й элемент -> ";
		std::cin >> d_arr[i];
	}
	std::cout << "Итоговый массив:\n";
	for (int i = 0; i < size; i++)
		std::cout << d_arr[i] << ' ';
	std::cout << std::endl;

	delete[] d_arr; // Освобождение памяти, выделенной под массив.
	
	// Отличия статических массивов от динамических: 
	/*
	1. Размер динамического массива может быть определён на этапе выполнения программы;
	2. С помощью специальных конструкций размер динамического массива может быть изменён;
	3. При работе с динамическим массивом необходимо следить за освобождением памяти;
	4. Работа со статическим массивом происходит гораздо быстрее. 
	5. Выделение памяти для храненения массивов с большим количеством измерений, чем 1,
	является сложным и долгим процессом. С точки зрения написания кода.
	*/

	//  ***** Двухмерный динамический массив. *****
	int rows, cols;
	std::cout << "Введите высоту двухмерного массива -> ";
	std::cout << rows;
	std::cout << "Введите длину двухмерного массива -> ";
	std::cout << cols;
	// int* mx = new int[rows][cols]; // Не работает!!
	int** mx = new int* [rows];
	for (int i = 0; i < rows; i++)
		mx[i] = new int[cols];

	// Использование массива точное такое же, как и у статического.
	
	// Освобождение памяти.
	for (int i = 0; i < rows; i++)
		delete[] mx[i];
	delete[] mx;

	// ***** Задача 1. Увеличение массива. *****
	std::cout << "Задача 1.\nВведите размер массива -> ";
	int size1;
	std::cin >> size1;
	int* arr1 = new int[size1];
	srand(time(NULL));
	std::cout << "Изначальный массив:\n[";
	for (int i = 0; i < size1; i++) {
		arr1[i] = rand() % (21 - 10) + 10; // [10 .. 20]
		std::cout << arr1[i] << ", ";
	}
	std::cout << "\b\b]\nВведите кол-во новых элементов -> ";
	std::cin >> n;
	
	arr_add(arr1, size1, n);
	size1 += n;

	std::cout << "Итоговый массив:\n[";
	for (int i = 0; i < size1; i++)
		std::cout << arr1[i] << ", ";
	std::cout << "\b\b]\n";

	return 0;
}